<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dominion POC â€” Player vs AI (v9.1)</title>
  <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAukB9GLZP2UAAAAASUVORK5CYII=" />
  <style>
    :root{
      /* Requested palette */
      --bg:#ECF2FF;             /* Background */
      --text:#0B0F14;           /* Primary text */
      --sub:#334155;            /* Subtle text */
      --panel:#FFFFFF;          /* Foreground cards/panels */
      --panel2:#F8FAFF;         /* Slight panel gradient tail */
      --outline:#CBD5E1;        /* Borders */
      --shadow:0 10px 24px rgba(2,6,23,.06);
      --accent:#0EA5E9;         /* Buttons & highlights */
      --accent-strong:#0284C7;  /* Button border / hover */
      --danger:#EF4444;
      --mint:#10B981;           /* Minty log */
      --chat:#FFFFFF;           /* Chat surface on light */
      --tipbg:#111827;          /* Tooltip/dialog background (requested) */
      --tipborder:#1F2937;      /* Tooltip/dialog border */
      --countBadge:#0F172A;     /* Dark badge on light */
    }

    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font:14px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}

    h1{font-size:22px;margin:12px 0 6px;color:var(--text)}
    .app{max-width:1200px;margin:18px auto;padding:12px}

    /* Header */
    .topbar{display:flex;align-items:flex-start;gap:16px;justify-content:space-between;background:linear-gradient(180deg,var(--panel),var(--panel2));border:1px solid var(--outline);border-radius:14px;padding:12px 16px;box-shadow:var(--shadow)}
    .top-left h1{margin:0}
    .control-line{margin-top:6px;color:var(--text)}
    .pill{display:inline-flex;gap:8px;align-items:center;background:#F1F5F9;border:1px solid var(--outline);border-radius:999px;padding:6px 10px}
    .toggle input, .toggle select{accent-color:var(--accent);background:#FFFFFF;border:1px solid var(--outline);color:var(--text);border-radius:8px;padding:6px 8px}
    .toggle select{padding-right:24px}

    .topbar-right{display:flex;flex-direction:column;align-items:stretch;gap:8px;width:260px}
    .btn{background:var(--accent);border:1px solid var(--accent-strong);border-radius:10px;padding:10px 12px;color:#fff;cursor:pointer;transition:transform .06s ease, filter .12s ease;width:100%;box-shadow:0 6px 18px rgba(14,165,233,.18)}
    .btn:hover{filter:brightness(1.05)}
    .btn:active{transform:translateY(1px)}

    .sound-controls{display:flex;gap:8px;align-items:center;background:#F1F5F9;border:1px solid var(--outline);border-radius:10px;padding:8px 10px;color:var(--text);width:100%}
    .sound-controls input[type="range"]{width:100%}

    .row{display:grid;grid-template-columns:1.2fr .8fr;gap:16px;margin-top:16px}
    .panel{background:linear-gradient(180deg,var(--panel),var(--panel2));border:1px solid var(--outline);border-radius:14px;box-shadow:var(--shadow);color:var(--text)}
    .panel h2{font-size:16px;margin:0;padding:10px 12px;border-bottom:1px solid var(--outline);color:var(--text)}

    /* Play Area soft vignette subtle on light */
    .playArea{position:relative;overflow:hidden}
    .playArea::after{content:"";position:absolute;inset:-20%;background:radial-gradient(600px 220px at 50% 10%, rgba(2,6,23,.06), rgba(2,6,23,0) 70%);pointer-events:none}

    /* Status */
    .stats{display:flex;gap:12px;align-items:center;color:var(--sub);flex-wrap:wrap}
    .pill strong{color:var(--text)}
    .stats-rows{padding:12px}
    .stats-rows .stats{margin:4px 0}
    .score{font-weight:800;color:#0369A1;font-size:16px}

    /* Supply */
    .supplySections{padding:12px}
    .supplySection{padding:12px 0;border-top:1px solid var(--outline)}
    .supplySection:first-child{border-top:0}
    .supplySection h3{margin:0 0 8px;color:#0F172A;font-size:13px;letter-spacing:.05em;text-transform:uppercase}
    .supplyGrid{display:grid;grid-template-columns:repeat(5,minmax(0,1fr));gap:10px}

    .pile{background:#FFFFFF;border:1px solid var(--outline);border-radius:12px;padding:10px;cursor:pointer;transition:transform .08s ease, box-shadow .08s ease;position:relative;box-shadow:0 8px 20px rgba(2,6,23,.04)}
    .pile:hover{transform:translateY(-1px);box-shadow:0 10px 24px rgba(2,6,23,.08)}
    .pile .name{display:flex;flex-direction:column;align-items:flex-start;gap:4px;padding-right:46px}
    .pile .name .icon{font-size:18px}
    .pile .name .label{font-weight:700;color:var(--text)}
    .pile .meta{font-size:12px;color:var(--sub)}
    .pile .count{position:absolute;right:8px;top:8px;background:#E2E8F0;border:1px solid #CBD5E1;border-radius:999px;padding:2px 8px;font-size:12px;color:#0F172A}
    .pile.disabled{opacity:.65;cursor:not-allowed}
    .pile.empty{background:repeating-linear-gradient(135deg,#FEE2E2,#FEE2E2 10px,#FECACA 10px,#FECACA 20px);border-color:var(--danger)}
    .pile.empty .count{background:#FECACA;border-color:#FCA5A5;color:#7F1D1D}
    .pile.empty::after{content:'EMPTY';position:absolute;left:-6px;top:8px;transform:rotate(-12deg);background:#FEE2E2;border:1px dashed var(--danger);color:#7F1D1D;font-weight:700;padding:2px 6px;border-radius:6px;font-size:11px}

    /* Buyable highlight */
    @keyframes pulseGlow{0%{box-shadow:0 0 0 0 rgba(14,165,233,.35)}70%{box-shadow:0 0 0 10px rgba(14,165,233,0)}100%{box-shadow:0 0 0 0 rgba(14,165,233,0)}}
    .pile.buyable{outline:2px solid var(--accent); animation:pulseGlow 1.6s ease-out infinite}

    /* Hand */
    .hand{display:flex;flex-wrap:wrap;gap:10px;padding:12px}
    .card{min-width:128px;background:#FFFFFF;border:1px solid var(--outline);border-radius:12px;padding:10px;box-shadow:0 8px 20px rgba(2,6,23,.04);cursor:default;position:relative}
    .card .title{font-weight:700;margin-bottom:6px;color:var(--text)}
    .card .type{font-size:12px;color:var(--sub)}
    .card.playable{outline:2px solid var(--accent);cursor:pointer}
    .card.disabled{opacity:.6;cursor:not-allowed;outline:none}

    .log{min-height:28px;padding:10px 12px;color:#0F172A;white-space:pre-wrap}
    .log .mint{color:var(--mint)}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size:12px; white-space:pre-wrap}
    .toast{position:fixed;bottom:18px;right:18px;background:#111827;border:1px solid #1F2937;color:#fff;padding:10px 14px;border-radius:12px;box-shadow:0 10px 24px rgba(2,6,23,.35);opacity:0;transform:translateY(12px);transition:opacity .18s ease, transform .18s ease}
    .toast.show{opacity:1;transform:translateY(0)}

    .build{position:fixed;right:10px;bottom:8px;font-size:12px;color:#0369A1;pointer-events:none;font-weight:800;text-shadow:0 0 12px rgba(2,132,199,.35)}

    /* Counts */
    .countsList{font-size:14px;line-height:1.35;color:var(--text);padding:12px}
    .countGroup{margin-bottom:8px}
    .countsList .row{display:flex;justify-content:space-between;margin:0;line-height:1.2}
    .countsList .label{color:var(--text)}
    .countsList .sub{font-size:12px;color:var(--sub);margin:0 0 2px}
    .countsList .totalWrap{display:flex;flex-direction:column;align-items:flex-end}
    .countsList .mini{font-size:10px;text-transform:uppercase;letter-spacing:.06em;color:var(--sub)}
    .countsList .totalNum{font-size:16px;color:var(--text)}

    /* Modal / Dialogs (requested dark) */
    .overlay{position:fixed;inset:0;background:rgba(2,6,23,.45);display:none;align-items:center;justify-content:center;z-index:9000}
    .overlay.show{display:flex}
    .modal{background:var(--tipbg);border:1px solid var(--tipborder);border-radius:16px;box-shadow:0 20px 60px rgba(2,6,23,.5);padding:18px 18px 14px;max-width:620px;min-width:360px;display:flex;flex-direction:column;align-items:center;text-align:center;color:#E5E7EB}
    .modal h3{margin:0 0 6px;font-size:22px;color:#fff}
    .modal p{margin:6px 0 14px;color:#D1D5DB}
    .modal .footer{margin-top:10px;width:100%;display:flex;justify-content:center}

    /* Tooltip (dark to match dialogs) */
    .tooltip{position:fixed;z-index:10050;display:none;max-width:260px;background:var(--tipbg);border:1px solid var(--tipborder);border-radius:10px;box-shadow:0 16px 36px rgba(2,6,23,.35);padding:8px 10px;color:#E5E7EB}
    .tooltip .tTitle{font-weight:700;margin-bottom:4px;color:#fff}
    .tooltip .tMeta{font-size:12px;color:#CBD5E1}

    /* Chat bot (light surface) */
    .chat-panel{position:fixed;right:18px;bottom:88px;width:320px;max-height:60vh;display:flex;flex-direction:column;background:var(--chat);border:1px solid var(--outline);border-radius:14px;box-shadow:var(--shadow);overflow:hidden;z-index:10020;color:var(--text)}
    .chat-head{display:flex;align-items:center;justify-content:space-between;padding:8px 10px;background:#F1F5F9;border-bottom:1px solid var(--outline);color:var(--text)}
    .chat-head .title{font-weight:700}
    .chat-body{padding:10px;overflow:auto;display:flex;flex-direction:column;gap:8px}
    .msg{display:flex;gap:8px;align-items:flex-start}
    .msg .bubble{padding:8px 10px;border-radius:10px;max-width:240px}
    .msg.bot .bubble{background:#E0F2FE;border:1px solid #BAE6FD;color:#0B0F14}
    .msg.user{justify-content:flex-end}
    .msg.user .bubble{background:#DBEAFE;border:1px solid #93C5FD;color:#0B0F14}
    .chat-input{display:flex;gap:6px;padding:10px;border-top:1px solid var(--outline);background:#F8FAFF}
    .chat-input input{flex:1;background:#FFFFFF;color:var(--text);border:1px solid var(--outline);border-radius:10px;padding:8px}
    .chat-input button{background:var(--accent);color:#fff;border:1px solid var(--accent-strong);border-radius:10px;padding:8px 10px;cursor:pointer}

  </style>

<style>
  /* v9.1 override per Greg: coin, action, victory cards use #E5E7EB */
  .pile { background-color: #E5E7EB !important; }
  .card { background-color: #E5E7EB !important; }
</style>

</head>
<body>
  <div class="app">
    <div class="topbar">
      <div class="top-left">
        <h1>Dominion â€” POC (You vs AI)</h1>
        <div class="control-line"><label class="pill toggle"><input type="checkbox" id="autoAdvance"> Auto-advance phases</label></div>
        <div class="control-line"><label class="pill toggle"><input type="checkbox" id="debugAICheck"> Watch the AI</label></div>
        <div class="control-line">
          <label class="pill toggle">AI:
            <select id="aiMode">
              <option value="weak">Weak</option>
              <option value="strong" selected>Strong</option>
            </select>
          </label>
        </div>
      </div>
      <div class="topbar-right">
        <!-- Stacked controls with equal width -->
        <button class="btn" id="newGameBtn">New Game</button>
        <button class="btn" id="tutorialBtn" title="Show the tutorial">Tutorial</button>
        <div class="sound-controls">
          <span>ðŸ”Š</span>
          <input type="range" id="vol" min="0" max="100" step="1" />
          <label class="toggle" style="margin-left:auto"><input type="checkbox" id="muteToggle"> Mute</label>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="panel">
        <h2>Supply</h2>
        <div id="supply" class="supplySections"></div>
      </div>
      <div class="panel">
        <h2>AI Status & Log</h2>
        <div class="log" id="ai-status">Waiting for your turnâ€¦</div>
        <div class="log mono" id="ai-debug" style="display:none"></div>
        <div class="log mono" id="log">Action > Treasure > Buy. Once you buy, you can't play more cards this turn.</div>
      </div>
    </div>

    <div class="row" style="margin-top:16px">
      <div class="panel">
        <h2>Game Status</h2>
        <div class="stats-rows">
          <div class="stats">
            <span class="pill score">Score: <span style="opacity:.9">You</span> <strong id="pScore">0</strong> Â· AI <strong id="aScore">0</strong></span>
          </div>
          <div class="stats">
            <span class="pill">Phase: <strong id="phase">Action</strong></span>
          </div>
          <div class="stats">
            <span class="pill">Actions: <strong id="actions">1</strong></span>
            <span class="pill">Buys: <strong id="buys">1</strong></span>
            <span class="pill">Coins: <strong id="coins">0</strong></span>
          </div>
        </div>
      </div>
      <div class="panel">
        <h2>Your Cards</h2>
        <div id="playerCounts" class="countsList"></div>
      </div>
    </div>

    <div class="panel playArea" style="margin-top:16px">
      <h2>Your Hand</h2>
      <div id="player-hand" class="hand"></div>
      <div class="actions" style="display:flex;gap:10px;align-items:center;padding:0 12px 12px;flex-wrap:wrap">
        <button class="btn" id="toBuyBtn" title="B" style="width:auto">Go to Buy Phase</button>
        <button class="btn" id="autoTreasureBtn" title="T" style="width:auto">Auto-Play Treasures</button>
        <button class="btn" id="undoBtn" title="Z" style="width:auto">Undo last</button>
        <button class="btn" id="endTurnBtn" title="E" style="width:auto">End Turn</button>
      </div>
      <div class="log mono" style="opacity:.85;padding:0 12px 12px">Shortcuts: A=play Action, T=auto-Treasure, B=Buy, E=End Turn, Z=Undo</div>
    </div>
  </div>

  <!-- Chat ALWAYS open -->
  <div class="chat-panel" id="chatPanel">
    <div class="chat-head"><span class="title">Table Talk</span><div class="tools"><button class="btn" id="clearChat" title="Clear chat" style="width:auto">ðŸ§¹</button></div></div>
    <div class="chat-body" id="chatBody"></div>
    <div class="chat-input"><input id="chatInput" placeholder="Say somethingâ€¦"/><button id="chatSend">Send</button></div>
  </div>

  <div class="toast" id="toast"></div>
  <div class="build" id="build"></div>

  <div class="overlay" id="overlay">
    <div class="modal" id="modal">
      <h3 id="winnerTitle">Game Over</h3>
      <p id="winnerDetail"></p>
      <div class="footer"><button class="btn" onclick="location.reload()" style="width:auto">New Game</button></div>
    </div>
  </div>

  <!-- Choice overlay (e.g., Workshop) -->
  <div class="overlay" id="choiceOverlay">
    <div class="modal" id="choiceModal">
      <h3 id="choiceTitle">Gain a card</h3>
      <p id="choiceDetail">Pick a card.</p>
      <div id="choiceGrid" class="supplyGrid"></div>
    </div>
  </div>

  <!-- Guided tour overlay -->
  <div class="overlay coach" id="coach" style="background:rgba(2,6,23,.45)">
    <div class="modal step" id="coachStep" style="left:40px;top:40px;min-width:300px">
      <div class="title" id="coachTitle" style="font-weight:800;margin-bottom:4px;color:#fff">Welcome!</div>
      <div id="coachText" style="color:#D1D5DB">Letâ€™s do a quick tour.</div>
      <div class="controls" style="display:flex;gap:8px;margin-top:10px">
        <button class="btn" id="coachSkip" style="width:auto">Skip</button>
        <button class="btn" id="coachNext" style="width:auto">Next â†’</button>
      </div>
    </div>
  </div>

  <div class="tooltip" id="tooltip"></div>

<script>
// ------------------- Build Tag & Favicon -------------------
const BUILD = { num: 'v9.1', date: new Date().toLocaleDateString(undefined,{year:'numeric',month:'short',day:'2-digit'}) };
(function(){
  document.getElementById('build').textContent = `Build ${BUILD.num} â€¢ ${BUILD.date}`;
  // Use provided G.png as favicon when available
  const candidates = ['G.png','./G.png','/mnt/data/G.png'];
  function setFav(url){ let link=document.querySelector('link[rel="icon"]'); if(!link){ link=document.createElement('link'); link.rel='icon'; document.head.appendChild(link);} link.href=url; }
  (function tryNext(i){ if(i>=candidates.length) return; const img=new Image(); img.onload=()=> setFav(candidates[i]); img.onerror=()=> tryNext(i+1); img.src=candidates[i]; })(0);
})();

// ------------------- Sound Engine -------------------
const Sound = {
  ctx: null, master: null, vol: 0.6, muted: false, key:'dominion_sound_v1',
  ensure(){ if(this.ctx) return; try{ this.ctx = new (window.AudioContext||window.webkitAudioContext)(); this.master = this.ctx.createGain(); this.master.gain.value = this.muted?0:this.vol; this.master.connect(this.ctx.destination); }catch(e){ console.warn('Audio init failed', e); } },
  resume(){ try{ this.ensure(); if(this.ctx && this.ctx.state==='suspended') this.ctx.resume(); }catch(e){} },
  setVolume(v){ this.vol = v; if(this.master && !this.muted) this.master.gain.value = this.vol; this.persist(); },
  setMuted(m){ this.muted = m; if(this.master) this.master.gain.value = this.muted?0:this.vol; this.persist(); },
  persist(){ try{ localStorage.setItem(this.key, JSON.stringify({vol:this.vol, muted:this.muted})); }catch(e){} },
  load(){ try{ const s = JSON.parse(localStorage.getItem(this.key)||'null'); if(s){ this.vol = s.vol??this.vol; this.muted = !!s.muted; } }catch(e){} },
  now(){ this.ensure(); return this.ctx? this.ctx.currentTime : 0; },
  env(node, t, a=0.005, d=0.08, s=0.0, r=0.12, g=0.5){ const gnode = this.ctx.createGain(); node.connect(gnode); gnode.connect(this.master); const v = g; gnode.gain.setValueAtTime(0, t); gnode.gain.linearRampToValueAtTime(v, t+a); gnode.gain.linearRampToValueAtTime(v*s, t+a+d); gnode.gain.linearRampToValueAtTime(0.0001, t+a+d+r); },
  tone(freq=440, dur=0.12, type='sine', gain=0.5){ if(!this.ctx || this.muted) return; const t=this.now(); const o=this.ctx.createOscillator(); o.type=type; o.frequency.setValueAtTime(freq, t); this.env(o,t,0.005, dur*0.6, 0.0, dur*0.4, gain); o.start(t); o.stop(t+dur+0.2); },
  chirp(f1=300, f2=900, dur=0.15, type='triangle', gain=0.35){ if(!this.ctx || this.muted) return; const t=this.now(); const o=this.ctx.createOscillator(); o.type=type; o.frequency.setValueAtTime(f1, t); o.frequency.linearRampToValueAtTime(f2, t+dur); this.env(o,t,0.005, dur*0.7, 0.0, 0.12, gain); o.start(t); o.stop(t+dur+0.2); },
  noise(dur=0.15, gain=0.25, band=[300,2000]){ if(!this.ctx || this.muted) return; const t=this.now(); const buf=this.ctx.createBuffer(1, this.ctx.sampleRate*dur, this.ctx.sampleRate); const data=buf.getChannelData(0); for(let i=0;i<data.length;i++){ data[i]=Math.random()*2-1; } const src=this.ctx.createBufferSource(); src.buffer=buf; let node=src; if(band){ const bp=this.ctx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=(band[0]+band[1])/2; bp.Q.value=3; src.connect(bp); node=bp; } this.env(node,t,0.005, dur*0.5, 0.0, 0.15, gain); src.start(t); src.stop(t+dur+0.2); },
  seq(notes){ if(!this.ctx || this.muted) return; const base=this.now(); notes.forEach(n=>{ const t=base+(n.t||0); const o=this.ctx.createOscillator(); o.type=n.type||'sine'; o.frequency.setValueAtTime(n.f, t); this.env(o,t,0.005,(n.d||0.1)*0.7,0.0,(n.d||0.1)*0.3,n.g||0.4); o.start(t); o.stop(t+(n.d||0.1)+0.2); }); },
  play(kind){ switch(kind){ case 'draw': this.chirp(320,520,0.08,'triangle',0.25); break; case 'action': this.chirp(420,860,0.12,'triangle',0.35); break; case 'coins': this.seq([{t:0,f:900,d:0.05,g:0.35,type:'square'},{t:0.06,f:1200,d:0.05,g:0.25,type:'square'}]); break; case 'buy': this.seq([{t:0,f:660,d:0.1,g:0.35},{t:0.12,f:990,d:0.1,g:0.25}]); break; case 'shuffle': this.noise(0.25,0.22,[200,3000]); break; case 'attack': this.seq([{t:0,f:220,d:0.14,g:0.4,type:'sawtooth'},{t:0.1,f:180,d:0.12,g:0.35,type:'sawtooth'}]); break; case 'reaction': this.chirp(500,1000,0.16,'sine',0.3); break; case 'error': this.tone(140,0.18,'sawtooth',0.35); break; case 'end': this.seq([{t:0,f:660,d:0.1,g:0.35},{t:0.12,f:880,d:0.12,g:0.35},{t:0.26,f:1320,d:0.16,g:0.25}]); break; } }
};
Sound.load();
['pointerdown','keydown'].forEach(ev=> document.addEventListener(ev, ()=>Sound.resume(), {once:true}));

// ------------------- Card Definitions -------------------
const CARD_DEFS = {
  Copper:    { name:'Copper',    cost:0, type:'Treasure', value:1, desc:'+1 coin' },
  Silver:    { name:'Silver',    cost:3, type:'Treasure', value:2, desc:'+2 coins' },
  Gold:      { name:'Gold',      cost:6, type:'Treasure', value:3, desc:'+3 coins' },
  Estate:    { name:'Estate',    cost:2, type:'Victory',  points:1, desc:'Worth 1 VP at end of game' },
  Duchy:     { name:'Duchy',     cost:5, type:'Victory',  points:3, desc:'Worth 3 VP at end of game' },
  Province:  { name:'Province',  cost:8, type:'Victory',  points:6, desc:'Worth 6 VP at end of game' },
  Smithy:    { name:'Smithy',    cost:4, type:'Action',   desc:'+3 cards',
               effect: (g,actor)=>{ drawCards(actor,3); if(actor===g.player) addLog(`You played Smithy and drew 3 cards.`); } },
  Village:   { name:'Village',   cost:3, type:'Action',   desc:'+1 card, +2 actions',
               effect: (g,actor)=>{ drawCards(actor,1); if(actor===g.player){ g.actions += 2; addLog(`You played Village: +1 card, +2 actions.`);} else { g.aiActions += 2; } } },
  Market:    { name:'Market',    cost:5, type:'Action',   desc:'+1 card, +1 action, +1 buy, +1 coin',
               effect: (g,actor)=>{ drawCards(actor,1); if(actor===g.player){ g.actions += 1; g.buys += 1; g.coins += 1; addLog('You played Market: +1 card, +1 action, +1 buy, +1 coin.'); } else { g.aiActions += 1; g.aiBuys += 1; g.aiCoins += 1; } } },
  Laboratory:{ name:'Laboratory',cost:5, type:'Action',   desc:'+2 cards, +1 action',
               effect: (g,actor)=>{ drawCards(actor,2); if(actor===g.player){ g.actions += 1; addLog('You played Laboratory: +2 cards, +1 action.'); } else { g.aiActions += 1; } } },
  Festival:  { name:'Festival',  cost:5, type:'Action',   desc:'+2 actions, +1 buy, +2 coins',
               effect: (g,actor)=>{ if(actor===g.player){ g.actions += 2; g.buys += 1; g.coins += 2; addLog('You played Festival: +2 actions, +1 buy, +2 coins.'); } else { g.aiActions += 2; g.aiBuys += 1; g.aiCoins += 2; } } },
  Woodcutter:{ name:'Woodcutter',cost:3, type:'Action',   desc:'+1 buy, +2 coins',
               effect: (g,actor)=>{ if(actor===g.player){ g.buys += 1; g.coins += 2; addLog('You played Woodcutter: +1 buy, +2 coins.'); } else { g.aiBuys += 1; g.aiCoins += 2; } } },
  Merchant:  { name:'Merchant',  cost:3, type:'Action',   desc:'Draw 1, +1 Action. The first time you play a Silver this turn, +$1.',
               effect: (g,actor)=>{ drawCards(actor,1); if(actor===g.player){ g.actions += 1; g.merchantPending.player++; addLog('You played Merchant: +1 card, +1 action. The first time you play a Silver this turn, +$1.'); } else { g.aiActions += 1; g.merchantPending.ai++; } } },
  Workshop:  { name:'Workshop',  cost:3, type:'Action',   desc:'Gain a card costing up to 4 to your discard',
               effect: (g,actor)=>{ if(actor===g.player){ openGainChoice(4, g.player, 'Workshop'); } else { const pick = aiGainChoiceUpTo(4); if(pick){ const pile=getPile(pick); if(pile&&pile.count>0){ pile.count--; g.ai.discard.push(instance(pick)); } } } } },
};

const SUPPLY = [
  { key:'Copper',   count:60 },
  { key:'Silver',   count:40 },
  { key:'Gold',     count:30 },
  { key:'Estate',   count:24 },
  { key:'Duchy',    count:12 },
  { key:'Province', count:12 },
  { key:'Smithy',   count:10 },
  { key:'Village',  count:10 },
  { key:'Market',   count:10 },
  { key:'Laboratory',count:10 },
  { key:'Festival', count:10 },
  { key:'Woodcutter',count:10 },
  { key:'Merchant', count:10 },
  { key:'Workshop', count:10 },
];

// ------------------- Game State -------------------
const game = {
  player:{ deck:[], discard:[], hand:[], played:[] },
  ai:     { deck:[], discard:[], hand:[], played:[] },
  actions:1, buys:1, coins:0, turn:'player', phase:'action',
  autoAdvance:true,
  debugAI:false,
  aiActions:1, aiBuys:1, aiCoins:0,
  endAfterThisTurn:false, gameOver:false,
  aiMode:'strong',
  undo:null,
  undoForbidden:null,
  suppressAutoAdvanceOnce:false,
  interactionLock:false,
  merchantPending:{ player:0, ai:0 },
  turnNum:1,
};

// ------------------- Log & Tooltip -------------------
const LOG_MAX = 10; let LOG_SILENT=false; const logs = [];
function addLog(msg, cls){ if(LOG_SILENT) return; logs.push({msg, cls}); while(logs.length>LOG_MAX) logs.shift(); const el = document.getElementById('log'); if(el) el.innerHTML = logs.map(l=>`<span class="${l.cls||''}">â€¢ ${l.msg}</span>`).join('\n'); }
function toast(msg){ const t=document.getElementById('toast'); t.textContent=msg; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'), 1800); }

const tip = document.getElementById('tooltip');
function showTip(html, x, y){ tip.innerHTML = html; tip.style.display='block'; const pad=10; const w=260; const h= tip.offsetHeight||100; let left = Math.min(window.innerWidth - w - pad, x + 14); let top  = Math.min(window.innerHeight - h - pad, y + 14); tip.style.left = left + 'px'; tip.style.top = top + 'px'; }
function hideTip(){ tip.style.display='none'; }
function cardTip(def){ const meta = []; if(def.type==='Treasure') meta.push(`+${def.value} coins`); if(def.type==='Victory') meta.push(`${def.points} VP`); if(def.type==='Action') meta.push(def.desc||'Action'); return `<div class="tTitle">${def.name}</div><div class="tMeta">Type: ${def.type} Â· Cost: ${def.cost}</div><div style=\"margin-top:4px\">${meta.join(' Â· ')}</div>`; }

// ------------------- Helpers -------------------
function instance(name){ return { ...CARD_DEFS[name] }; }
function deepClone(obj){ return JSON.parse(JSON.stringify(obj)); }
function packActor(actor){ return { deck: actor.deck.map(c=>c.name), discard: actor.discard.map(c=>c.name), hand: actor.hand.map(c=>c.name), played: actor.played.map(c=>c.name) }; }
function unpackActor(p){ return { deck: p.deck.map(instance), discard: p.discard.map(instance), hand: p.hand.map(instance), played: p.played.map(instance) }; }
function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } }
function drawOne(actor){ if(actor.deck.length===0){ actor.deck.push(...actor.discard); actor.discard.length=0; shuffle(actor.deck); if(actor===game.player){ addLog('Your deck was shuffled.', 'mint'); Chat.say('shuffle'); } Sound.play('shuffle'); } if(actor.deck.length>0){ actor.hand.push(actor.deck.pop()); if(actor===game.player) Sound.play('draw'); }
  if(actor===game.player && game.turn==='player' && game.undo){ game.undoForbidden='draw'; } }
function drawCards(actor,n){ for(let i=0;i<n;i++) drawOne(actor); }
function vpOfPile(pile){ return pile.reduce((sum,c)=> sum + (c.points||0), 0); }
function computeScores(){ const p = vpOfPile([...game.player.deck,...game.player.discard,...game.player.hand]); const a = vpOfPile([...game.ai.deck,...game.ai.discard,...game.ai.hand]); return {p,a}; }
function cardIcon(name){ switch(name){ case 'Copper': return 'ðŸŸ '; case 'Silver': return 'âšªï¸'; case 'Gold': return 'ðŸŸ¡'; case 'Estate': return 'ðŸ '; case 'Duchy': return 'ðŸ¯'; case 'Province': return 'ðŸ°'; case 'Smithy': return 'âš’ï¸'; case 'Village': return 'ðŸ˜ï¸'; case 'Market': return 'ðŸ›’'; case 'Laboratory': return 'ðŸ§ª'; case 'Festival': return 'ðŸŽª'; case 'Woodcutter': return 'ðŸª“'; case 'Merchant': return 'ðŸª™'; case 'Workshop': return 'ðŸ§°'; default: return 'ðŸƒ'; } }

function isChoiceOpen(){ return document.getElementById('choiceOverlay').classList.contains('show'); }
function closeChoiceOverlay(){ const over=document.getElementById('choiceOverlay'); over.classList.remove('show'); game.interactionLock=false; }
function syncLockFromOverlay(){ game.interactionLock = isChoiceOpen(); }
function hasPlayableAction(){ return !game.interactionLock && game.actions>0 && game.player.hand.some(c=>c.type==='Action'); }
function hasTreasure(){ return !game.interactionLock && game.player.hand.some(c=>c.type==='Treasure'); }
function maybeAutoAdvance(){ if(game.interactionLock) return false; if(game.suppressAutoAdvanceOnce){ game.suppressAutoAdvanceOnce=false; return false; } if(!game.autoAdvance || game.gameOver) return false; let changed=false; if(game.phase==='action' && !hasPlayableAction()){ game.phase='treasure'; changed=true; } if(game.phase==='treasure' && !hasTreasure()){ game.phase='buy'; changed=true; } return changed; }

function emptyPileCount(){ return SUPPLY.reduce((n,p)=> n + (p.count===0?1:0), 0); }
function getPile(name){ return SUPPLY.find(p=>p.key===name); }
function checkEndgameFlags(){ const prov = getPile('Province'); if(prov && prov.count===0) game.endAfterThisTurn = true; if(emptyPileCount() >= 3)  game.endAfterThisTurn = true; if(game.endAfterThisTurn) addLog('End condition met - game will end after this turn.'); }
function showWinner(){ const {p,a} = computeScores(); const title = (p>a)? 'You win!': (a>p? 'AI wins.':'Tie game.'); document.getElementById('winnerTitle').textContent = title; document.getElementById('winnerDetail').textContent = `Final score - You: ${p} Â· AI: ${a}`; document.getElementById('overlay').classList.add('show'); Sound.play('end'); Chat.endGame(title, {p,a}); }

function phaseBand(){ const prov = getPile('Province'); const left = prov? prov.count : 12; if(left <= 3) return 'late'; if(left <= 7) return 'mid'; return 'early'; }

// Player counts HTML
function playerCountsHTML(){ const all=[...game.player.deck, ...game.player.discard, ...game.player.hand]; const map={}; const typeTotals={Treasure:0, Victory:0, Action:0}; all.forEach(c=>{ map[c.name]=(map[c.name]||0)+1; typeTotals[c.type]=(typeTotals[c.type]||0)+1; }); const block=(label,names)=>{ const total = typeTotals[label]||0; const details = names.map(n=> `${n} ${map[n]||0}`).join(' Â· '); return `<div class=\"countGroup\"><div class=\"row\"><span class=\"label\">${label}</span><span class=\"totalWrap\"><span class=\"mini\">total</span><span class=\"totalNum\"><strong>${total}</strong></span></span></div><div class=\"sub\">${details}</div></div>`; }; return [ block('Treasure',['Gold','Silver','Copper']), block('Victory',['Province','Duchy','Estate']), block('Action',['Festival','Laboratory','Market','Merchant','Smithy','Village','Workshop','Woodcutter']) ].join(''); }
let lastCountsHTML = '';

// ---------- Debug helpers ----------
function groupByName(cards){ const m = new Map(); cards.forEach(c=> m.set(c.name, (m.get(c.name)||0)+1)); return [...m.entries()].sort((a,b)=> a[0].localeCompare(b[0])).map(([n,k])=> `${n}Ã—${k}`).join(', '); }
function writeAIDebug(lines){ const box = document.getElementById('ai-debug'); if(!box) return; if(!game.debugAI){ box.style.display='none'; box.textContent=''; return; } box.style.display='block'; box.textContent = (lines||[]).join('\n'); }

// ------------------- Choice overlay (Workshop) -------------------
function openGainChoice(maxCost, actor, source){
  game.interactionLock = true; updateUndoUI();
  const over = document.getElementById('choiceOverlay');
  const grid = document.getElementById('choiceGrid'); grid.innerHTML = '';
  document.getElementById('choiceTitle').textContent = 'Gain a card';
  document.getElementById('choiceDetail').textContent = `Pick a card costing up to ${maxCost}.`;
  const eligible = SUPPLY.filter(p=> p.count>0 && CARD_DEFS[p.key].cost<=maxCost);
  eligible.sort((a,b)=> CARD_DEFS[b.key].cost - CARD_DEFS[a.key].cost || a.key.localeCompare(b.key));
  eligible.forEach(pile=>{
    const def = CARD_DEFS[pile.key];
    const el = document.createElement('div'); el.className='pile';
    el.innerHTML = `
      <div class=\"count\">${pile.count}</div>
      <div class=\"name\">
        <div class=\"icon\">${cardIcon(def.name)}</div>
        <div class=\"label\">${def.name}</div>
      </div>
      <div class=\"meta\">Cost: ${def.cost}</div>
    `;
    el.onclick = ()=>{
      pile.count--; actor.discard.push(instance(def.name));
      addLog(`You gained ${def.name} with ${source}.`);
      over.classList.remove('show');
      game.interactionLock = false; updateUndoUI(); checkEndgameFlags(); render();
    };
    el.addEventListener('mouseenter', (e)=> showTip(cardTip(def), e.clientX, e.clientY));
    el.addEventListener('mousemove',  (e)=> showTip(cardTip(def), e.clientX, e.clientY));
    el.addEventListener('mouseleave', hideTip);
    grid.appendChild(el);
  });
  over.classList.add('show');
}

// ------------------- Undo -------------------
function snapshot(){ if(game.turn!=='player' || game.gameOver || game.interactionLock) return; game.undo = { turn: game.turn, phase: game.phase, actions: game.actions, buys: game.buys, coins: game.coins, endAfter: game.endAfterThisTurn, playerPacked: packActor(game.player), supply: SUPPLY.map(p=>p.count), logs: deepClone(logs), merchantPending: deepClone(game.merchantPending), turnNum: game.turnNum, }; game.undoForbidden = null; updateUndoUI(); }
function canUndo(){ return !!game.undo; }
function undo(){ if(!canUndo()) return; if(game.undoForbidden==='draw'){ Sound.play('error'); toast('You cannot use undo after a card draw.'); return; } if(isChoiceOpen()) closeChoiceOverlay(); const u = game.undo; game.turn  = u.turn; game.phase = u.phase; game.actions = u.actions; game.buys = u.buys; game.coins = u.coins; game.endAfterThisTurn = u.endAfter; game.player = unpackActor(u.playerPacked); SUPPLY.forEach((p,i)=> p.count = u.supply[i]); logs.length = 0; u.logs.forEach(x=> logs.push(x)); game.merchantPending = u.merchantPending; game.turnNum = u.turnNum; game.undo = null; game.interactionLock = false; game.suppressAutoAdvanceOnce = true; updateUndoUI(); addLog(`Undid last action. Restored phase: ${game.phase}, actions: ${game.actions}, buys: ${game.buys}, coins: ${game.coins}.`, 'mint'); render(); }
function updateUndoUI(){ const b = document.getElementById('undoBtn'); if(b) b.disabled = !canUndo(); }

// ------------------- Init -------------------
function init(){
  const p=game.player, a=game.ai;
  for(let i=0;i<7;i++){ p.deck.push(instance('Copper')); a.deck.push(instance('Copper')); }
  for(let i=0;i<3;i++){ p.deck.push(instance('Estate')); a.deck.push(instance('Estate')); }
  shuffle(p.deck); shuffle(a.deck);
  for(let i=0;i<5;i++){ drawOne(p); drawOne(a); }
  document.getElementById('autoAdvance').checked=game.autoAdvance;
  document.getElementById('autoAdvance').onchange=(e)=>{ game.autoAdvance=e.target.checked; };
  const sel=document.getElementById('aiMode'); sel.value=game.aiMode; sel.onchange=(e)=>{ game.aiMode=e.target.value; toast(`AI set to ${game.aiMode}`); };
  const dbg=document.getElementById('debugAICheck'); dbg.checked=game.debugAI; dbg.onchange=(e)=>{ game.debugAI=e.target.checked; writeAIDebug([]); };

  // Top-right controls
  document.getElementById('newGameBtn').onclick = ()=> location.reload();
  document.getElementById('tutorialBtn').onclick = ()=>{ Coach.ensureInit(); Coach.restart(); };

  // Sound UI
  const v = document.getElementById('vol'); const m = document.getElementById('muteToggle');
  v.value = Math.round(Sound.vol*100); m.checked = Sound.muted;
  v.oninput = (e)=>{ Sound.setVolume((+e.target.value)/100); };
  m.onchange = (e)=>{ Sound.setMuted(!!e.target.checked); };

  lastCountsHTML = playerCountsHTML();
  const pc = document.getElementById('playerCounts'); if(pc) pc.innerHTML = lastCountsHTML;
  addLog(`Build ${BUILD.num} ready. Your turn [${game.turnNum}].`);
  updateUndoUI();
  render();
  Chat.init();
  Chat.startGame?.();
  Coach.init(); Coach.maybeStart();
  setTimeout(sanityCheck, 0);
}

// ------------------- Rendering -------------------
function render(){
  syncLockFromOverlay();
  document.getElementById('actions').textContent = game.actions;
  document.getElementById('buys').textContent    = game.buys;
  document.getElementById('coins').textContent   = game.coins;
  document.getElementById('phase').textContent   = game.phase.charAt(0).toUpperCase()+game.phase.slice(1);
  const {p,a} = computeScores();
  document.getElementById('pScore').textContent = p;
  document.getElementById('aScore').textContent = a;
  const pc = document.getElementById('playerCounts'); if(pc) pc.innerHTML = lastCountsHTML;

  // SUPPLY
  const s = document.getElementById('supply'); s.innerHTML='';
  const groups = [ { title:'Coins', type:'Treasure' }, { title:'Victory Cards', type:'Victory' }, { title:'Action Cards', type:'Action' } ];
  const sortMetric = (def, type)=> type==='Victory' ? (def.points||0) : def.cost;
  groups.forEach(g=>{
    const sec = document.createElement('div'); sec.className='supplySection';
    const h = document.createElement('h3'); h.textContent = g.title; sec.appendChild(h);
    const grid = document.createElement('div'); grid.className='supplyGrid'; sec.appendChild(grid);

    SUPPLY.filter(p=>CARD_DEFS[p.key].type===g.type)
      .sort((a,b)=>{ const da=CARD_DEFS[a.key], db=CARD_DEFS[b.key]; const va=sortMetric(da,g.type), vb=sortMetric(db,g.type); return vb-va || a.key.localeCompare(b.key); })
      .forEach(pile=>{
        const def = CARD_DEFS[pile.key];
        const el = document.createElement('div'); el.className='pile'; if(pile.count===0) el.classList.add('empty');
        el.innerHTML = `
          <div class=\"count\">${pile.count}</div>
          <div class=\"name\">
            <div class=\"icon\">${cardIcon(def.name)}</div>
            <div class=\"label\">${def.name}</div>
          </div>
          <div class=\"meta\">Cost: ${def.cost}</div>
        `;
        const canBuy = (!game.gameOver && !game.interactionLock && game.turn==='player' && game.phase==='buy' && game.buys>0 && game.coins>=def.cost && pile.count>0);
        if(canBuy){ el.onclick = ()=>buy(def.name); el.classList.remove('disabled'); el.classList.add('buyable'); }
        else { el.classList.add('disabled'); el.classList.remove('buyable'); el.onclick = null; }
        el.addEventListener('mouseenter', (e)=> showTip(cardTip(def), e.clientX, e.clientY));
        el.addEventListener('mousemove',  (e)=> showTip(cardTip(def), e.clientX, e.clientY));
        el.addEventListener('mouseleave', hideTip);
        grid.appendChild(el);
      });
    s.appendChild(sec);
  });

  // HAND
  const hand = document.getElementById('player-hand'); hand.innerHTML='';
  const indexed = game.player.hand.map((c,idx)=>({c,idx}));
  const groupRank = { Action:0, Treasure:1, Victory:2 };
  indexed.sort((a,b)=>{ const ga = groupRank[a.c.type] ?? 3; const gb = groupRank[b.c.type] ?? 3; if(ga!==gb) return ga-gb; if(a.c.type==='Action' && b.c.type==='Action') return a.c.name.localeCompare(b.c.name); if(a.c.type==='Treasure' && b.c.type==='Treasure') return (b.c.value||0)-(a.c.value||0) || a.c.name.localeCompare(b.c.name); if(a.c.type==='Victory' && b.c.type==='Victory') return (b.c.points||0)-(a.c.points||0) || a.c.name.localeCompare(b.c.name); return a.c.name.localeCompare(b.c.name); });
  indexed.forEach(({c,idx})=>{
    const el = document.createElement('div'); el.className='card';
    el.innerHTML = `<div class=\"title\">${cardIcon(c.name)} ${c.name}</div><div class=\"type\">${c.type}</div>`;
    const canPlayAction = (!game.gameOver && !game.interactionLock && c.type==='Action' && game.turn==='player' && game.phase==='action' && game.actions>0);
    const canPlayTreasure = (!game.gameOver && !game.interactionLock && c.type==='Treasure' && game.turn==='player' && game.phase!=='buy');
    if(canPlayAction || canPlayTreasure){ el.classList.add('playable'); el.onclick = ()=>play(idx); }
    else { el.classList.add('disabled'); el.onclick = null; }
    const def = CARD_DEFS[c.name];
    el.addEventListener('mouseenter', (e)=> showTip(cardTip(def), e.clientX, e.clientY));
    el.addEventListener('mousemove',  (e)=> showTip(cardTip(def), e.clientX, e.clientY));
    el.addEventListener('mouseleave', hideTip);
    hand.appendChild(el);
  });

  // Buttons
  document.getElementById('endTurnBtn').onclick = ()=>{ if(!game.interactionLock){ Sound.play('end'); endTurn(); } };
  document.getElementById('autoTreasureBtn').onclick = ()=>{ if(game.interactionLock) return; if(game.phase==='action') game.phase='treasure'; snapshot(); autoPlayTreasures(); };
  document.getElementById('toBuyBtn').onclick = ()=>{ if(game.interactionLock) return; if(game.phase!=='buy'){ snapshot(); game.phase='buy'; addLog('Buy phase. Buying disables further card play this turn.'); render(); } };
  document.getElementById('undoBtn').onclick = undo;

  const changed = maybeAutoAdvance();
  if(changed) return render();
}

function endIfNeeded(){ if(game.endAfterThisTurn){ game.gameOver=true; showWinner(); return true; } return false; }

// ------------------- Actions & Buys (Player) -------------------
function play(index){ if(game.interactionLock || game.turn!=='player' || game.gameOver) return; const card = game.player.hand[index]; if(!card) return; snapshot(); if(card.type==='Action'){ if(game.phase!=='action' || game.actions<=0) return; game.actions -= 1; const [played] = game.player.hand.splice(index,1); game.player.played.push(played); if(typeof played.effect==='function') played.effect(game, game.player); Sound.play('action'); toast(`Played ${played.name}`); } else if(card.type==='Treasure'){ if(game.phase==='buy') { Sound.play('error'); return; } if(game.phase==='action') game.phase='treasure'; const [tre] = game.player.hand.splice(index,1); game.player.played.push(tre); let add = (tre.value||0); if(tre.name==='Silver' && game.merchantPending.player>0){ add += game.merchantPending.player; addLog(`Merchant boosts Silver: +${game.merchantPending.player}.`); game.merchantPending.player = 0; } game.coins += add; Sound.play('coins'); toast(`+${add} coins`); } render(); }

function autoPlayTreasures(){ if(game.turn!=='player' || game.phase==='buy' || game.gameOver) return; if(game.phase==='action') game.phase='treasure'; let added=0; let count=0; let sawSilver=false; for(let i=game.player.hand.length-1;i>=0;i--){ if(game.player.hand[i].type==='Treasure'){ const card = game.player.hand.splice(i,1)[0]; game.player.played.push(card); added += (card.value||0); count++; if(card.name==='Silver') sawSilver=true; } } if(sawSilver && game.merchantPending.player>0){ added += game.merchantPending.player; addLog(`Merchant boosts Silver: +${game.merchantPending.player}.`); game.merchantPending.player=0; } game.coins += added; if(count>0){ addLog(`Auto-played ${count} treasure${count>1?'s':''} for +${added} coins.`); Sound.play('coins'); toast(`Auto Treasures: +${added}`); } render(); }

function buy(name){ if(game.interactionLock || game.turn!=='player' || game.phase!=='buy' || game.gameOver) return; const pile = getPile(name); const def = CARD_DEFS[name]; if(!pile || !def || pile.count<=0) return; if(game.buys<=0){ Sound.play('error'); toast('No buys left'); return; } if(game.coins < def.cost){ Sound.play('error'); toast('Not enough coins'); return; } snapshot(); game.buys -= 1; game.coins -= def.cost; pile.count -= 1; game.player.discard.push(instance(def.name)); addLog(`You bought ${def.name} for ${def.cost}.`); Sound.play('buy'); toast(`Bought ${def.name} (-${def.cost})`); Chat.say?.('playerBuy', {name:def.name}); checkEndgameFlags(); render(); }

// ------------------- Turn Flow -------------------
function cleanupAndDraw(who){ who.discard.push(...who.hand, ...who.played); who.hand.length=0; who.played.length=0; for(let i=0;i<5;i++) drawOne(who); }
function endTurn(){ if(game.turn!=='player' || game.gameOver) return; game.undo = null; updateUndoUI(); cleanupAndDraw(game.player); lastCountsHTML = playerCountsHTML(); const pc = document.getElementById('playerCounts'); if(pc) pc.innerHTML = lastCountsHTML; if(endIfNeeded()) return; game.turn='ai'; game.actions=1; game.buys=1; game.coins=0; game.phase='action'; game.merchantPending.ai = 0; addLog('AI is thinking...'); render(); setTimeout(aiTurn, 300); }

// ------------------- AI -------------------
function aiPlayBestActionStrong(debug){ if(game.aiActions<=0) return false; const hand = game.ai.hand; const hasTerminal = hand.some(c=> c.name==='Smithy' || c.name==='Woodcutter' || c.name==='Workshop'); let idx = -1; if(hand.some(c=>c.name==='Village') && (game.aiActions<=1) && (hasTerminal)){ idx = hand.findIndex(c=>c.name==='Village'); } else if(hand.some(c=>c.name==='Festival')){ idx = hand.findIndex(c=>c.name==='Festival'); } else if(hand.some(c=>c.name==='Market')){ idx = hand.findIndex(c=>c.name==='Market'); } else if(hand.some(c=>c.name==='Laboratory')){ idx = hand.findIndex(c=>c.name==='Laboratory'); } else if(hand.some(c=>c.name==='Merchant')){ idx = hand.findIndex(c=>c.name==='Merchant'); } else if(hand.some(c=>c.name==='Smithy')){ idx = hand.findIndex(c=>c.name==='Smithy'); } else if(hand.some(c=>c.name==='Workshop')){ idx = hand.findIndex(c=>c.name==='Workshop'); } else if(hand.some(c=>c.name==='Village')){ idx = hand.findIndex(c=>c.name==='Village'); } else if(hand.some(c=>c.name==='Woodcutter')){ idx = hand.findIndex(c=>c.name==='Woodcutter'); } if(idx===-1) return false; game.aiActions -= 1; const [act] = hand.splice(idx,1); game.ai.played.push(act); if(debug) debug.push(`Action: ${act.name}`); if(typeof act.effect==='function') act.effect(game, game.ai); return true; }
function aiPlayBestActionWeak(debug){ if(game.aiActions<=0) return false; const hand = game.ai.hand; let order = ['Festival','Market','Laboratory','Merchant','Smithy','Workshop','Village','Woodcutter']; let idx = order.map(n=> hand.findIndex(c=>c.name===n)).find(i=>i!==-1) ?? -1; if(idx===-1) return false; game.aiActions -= 1; const [act] = hand.splice(idx,1); game.ai.played.push(act); if(debug) debug.push(`[Weak] Action: ${act.name}`); if(typeof act.effect==='function') act.effect(game, game.ai); game.aiActions = 0; return true; }
function aiAutoPlayTreasures(debug){ let add=0; const played=[]; let sawSilver=false; for(let i=game.ai.hand.length-1;i>=0;i--){ if(game.ai.hand[i].type==='Treasure'){ const t = game.ai.hand.splice(i,1)[0]; game.ai.played.push(t); add += (t.value||0); played.push(t); if(t.name==='Silver') sawSilver=true; } } if(sawSilver && game.merchantPending.ai>0){ add += game.merchantPending.ai; if(debug) debug.push(`Merchant bonus on Silver: +${game.merchantPending.ai}`); game.merchantPending.ai=0; } if(debug && played.length) debug.push(`Treasures: ${groupByName(played)} => +${add}`); game.aiCoins += add; return add; }
function aiCountInDeck(name){ const all=[...game.ai.deck,...game.ai.discard,...game.ai.hand,...game.ai.played]; return all.filter(c=>c.name===name).length; }
function aiGainChoiceUpTo(maxCost){ const provLeft = getPile('Province')?.count ?? 12; if(provLeft<=3){ if(maxCost>=2 && getPile('Estate').count>0) return 'Estate'; } const needVillage = aiCountInDeck('Village') < (aiCountInDeck('Smithy') + aiCountInDeck('Workshop'))/2; if(needVillage && maxCost>=3 && getPile('Village').count>0) return 'Village'; if(maxCost>=4 && getPile('Smithy').count>0) return 'Smithy'; if(maxCost>=3 && getPile('Silver').count>0) return 'Silver'; if(maxCost>=3 && getPile('Merchant').count>0) return 'Merchant'; const eligible = SUPPLY.filter(p=> p.count>0 && CARD_DEFS[p.key].cost<=maxCost); return eligible.length? eligible[Math.floor(Math.random()*eligible.length)].key : null; }
function aiChooseBuyStrong(debug){ const coins = game.aiCoins; const phase = phaseBand(); const piles = { Province:getPile('Province'), Duchy:getPile('Duchy'), Estate:getPile('Estate'), Gold:getPile('Gold'), Silver:getPile('Silver'), Smithy:getPile('Smithy'), Village:getPile('Village'), Market:getPile('Market'), Laboratory:getPile('Laboratory'), Festival:getPile('Festival'), Woodcutter:getPile('Woodcutter'), Merchant:getPile('Merchant'), Workshop:getPile('Workshop') }; const can = n=> n && n.count>0; let pick=null; if(coins>=8 && can(piles.Province)) pick='Province'; else if(coins>=6 && can(piles.Gold)) pick='Gold'; else if(coins>=5){ const prefs = ['Festival','Market','Laboratory','Smithy']; pick = prefs.find(n=> can(piles[n])) || null; } else if(coins>=4 && can(piles.Smithy)) pick='Smithy'; else if(coins>=3){ const prefs3 = ['Silver','Village','Merchant','Workshop','Woodcutter']; pick = prefs3.find(n=> can(piles[n])) || null; } if(phase==='late' && !pick){ if(coins>=5 && can(piles.Duchy)) pick='Duchy'; else if(coins>=2 && can(piles.Estate)) pick='Estate'; } if(debug) debug.push(`Buy choice: ${pick??'nothing'} (coins ${coins})`); return pick; }
function aiChooseBuyWeak(debug){ const coins = game.aiCoins; const provLeft = getPile('Province')?.count ?? 12; let pick=null; if(coins>=6) pick='Gold'; else if(coins>=5) pick=['Festival','Market','Laboratory'][Math.floor(Math.random()*3)]; else if(coins>=4) pick='Smithy'; else if(coins>=3) pick=['Silver','Merchant','Village','Workshop','Woodcutter'][Math.floor(Math.random()*5)]; if(!pick && provLeft<=3){ if(coins>=8) pick='Province'; else if(coins>=5) pick='Duchy'; else if(coins>=2) pick='Estate'; } if(!pick && coins===0 && Math.random()<0.3 && getPile('Copper').count>0) pick='Copper'; if(debug) debug.push(`[Weak] Buy choice: ${pick??'nothing'} (coins ${coins})`); return pick; }
function aiMultiBuy(debug, mode){ let boughtList=[]; let safety=5; while(game.aiBuys>0 && safety-->0){ const choice = (mode==='weak') ? aiChooseBuyWeak(debug) : aiChooseBuyStrong(debug); if(!choice) break; const pile = getPile(choice); const def = CARD_DEFS[choice]; if(!pile || pile.count<=0 || game.aiCoins < def.cost) break; pile.count--; game.ai.discard.push(instance(choice)); game.aiCoins -= def.cost; game.aiBuys -= 1; boughtList.push(choice); checkEndgameFlags(); } return boughtList; }
function aiTurn(){ if(game.gameOver) return; const debug = game.debugAI ? [`AI turn start - hand: ${groupByName(game.ai.hand)}`] : null; game.aiActions=1; game.aiBuys=1; game.aiCoins=0; game.merchantPending.ai = 0; const mode = game.aiMode; if(mode==='weak'){ aiPlayBestActionWeak(debug); } else { let playedSomething=true; let guard=10; while(playedSomething && guard-->0){ playedSomething = aiPlayBestActionStrong(debug); } } const gained = aiAutoPlayTreasures(debug); const boughtList = aiMultiBuy(debug, mode); const bought = boughtList.length? boughtList.join(', '): 'nothing'; document.getElementById('ai-status').textContent = `AI (${mode}) played ${gained} coin${gained===1?'':'s'} and bought ${bought}.`; if(game.debugAI){ if(boughtList.length){ debug.push(`Bought: ${boughtList.join(', ')}`); } debug.push(`End coins: ${game.aiCoins}, End buys: ${game.aiBuys}`); writeAIDebug(debug); } else { writeAIDebug([]); } cleanupAndDraw(game.ai); if(endIfNeeded()) return; game.turn='player'; game.merchantPending.player = 0; game.turnNum += 1; addLog(`Your turn [${game.turnNum}].`); Chat.say?.('aiTurn', {bought:boughtList, coins:gained}); render(); }

// ------------------- Keyboard Shortcuts -------------------
function firstPlayableActionIndex(){ if(game.turn!=='player' || game.phase!=='action' || game.actions<=0 || game.interactionLock) return -1; return game.player.hand.findIndex(c=>c.type==='Action'); }

document.addEventListener('keydown', (ev)=>{ const k = ev.key.toLowerCase(); if(k==='a'){ const idx = firstPlayableActionIndex(); if(idx>=0){ play(idx); ev.preventDefault(); } else { Sound.play('error'); } } else if(k==='t'){ if(game.interactionLock) return; if(game.phase==='action') game.phase='treasure'; snapshot(); autoPlayTreasures(); ev.preventDefault(); } else if(k==='b'){ if(game.interactionLock) return; if(game.phase!=='buy'){ snapshot(); game.phase='buy'; addLog('Buy phase. Buying disables further card play this turn.'); render(); } ev.preventDefault(); } else if(k==='e'){ if(game.interactionLock) return; Sound.play('end'); endTurn(); ev.preventDefault(); } else if(k==='z'){ undo(); ev.preventDefault(); } });

// ------------------- Chat Bot (persisted) -------------------
const Chat = { elPanel:null, elBody:null, elInput:null, said:new Set(), storageKey:'dominion_chat_v1', init(){ this.elPanel = document.getElementById('chatPanel'); this.elBody  = document.getElementById('chatBody'); this.elInput = document.getElementById('chatInput'); document.getElementById('chatSend').onclick = ()=> this.send(); document.getElementById('clearChat').onclick = ()=> this.clear(); this.elInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); this.send(); } }); this.load(); }, scroll(){ this.elBody.scrollTop = this.elBody.scrollHeight; }, variant(text){ const suf = [' â€¢',' â€¦',' ðŸ™‚',' ðŸ¤–',' âœ¨',' !',' ~'][Math.floor(Math.random()*7)]; let v = text + suf; while(this.said.has(v)) v = text + suf + Math.floor(Math.random()*9); return v; }, post(role, text){ if(role==='bot'){ if(this.said.has(text)) text = this.variant(text); this.said.add(text); } const line = document.createElement('div'); line.className = 'msg ' + (role==='bot'?'bot':'user'); const bubble = document.createElement('div'); bubble.className='bubble'; bubble.textContent=text; line.appendChild(bubble); this.elBody.appendChild(line); this.persist(); this.scroll(); }, postUnique(lines){ const pool = lines.filter(t=> !this.said.has(t)); const pick = (arr)=> arr[Math.floor(Math.random()*arr.length)]; const chosen = (pool.length? pick(pool) : this.variant(pick(lines))); this.post('bot', chosen); }, persist(){ const items = [...this.elBody.querySelectorAll('.msg')].slice(-150).map(n=>({ role: n.classList.contains('bot')? 'bot':'user', text: n.querySelector('.bubble')?.textContent || '' })); try{ localStorage.setItem(this.storageKey, JSON.stringify({items, said:[...this.said].slice(-500)})); }catch(e){} }, load(){ try{ const raw = localStorage.getItem(this.storageKey); if(!raw) return; const data = JSON.parse(raw); this.said = new Set(Array.isArray(data?.said)? data.said: []); (data?.items||[]).forEach(it=> this.post(it.role, it.text)); }catch(e){} }, clear(){ this.elBody.innerHTML=''; this.said.clear(); this.persist(); }, send(){ const v = this.elInput.value.trim(); if(!v) return; this.post('user', v); this.elInput.value=''; setTimeout(()=> this.reply(v), 120); }, reply(text){ const t = text.toLowerCase(); if(t.includes('help')||t.includes('how')) return this.post('bot', 'Phases go Action â†’ Treasure â†’ Buy. Hit T to auto-play treasures, B to buy, Z to undo.'); if(t.includes('why') && t.includes('buy')) return this.post('bot', 'Simple plan: build economy (Silver/Gold), add Market/Festival, sprinkle Merchants, green when Provinces drop.'); if(t.includes('score')){ const {p,a}=computeScores(); return this.post('bot', `VP check â†’ You: ${p}, AI: ${a}.`); } this.postUnique(['Auto-Treasure (T) saves clicks; Undo (Z) saves regrets.','Greening too early can stallâ€”watch Province pile count.','Merchants love Silvers; your first Silver each turn gets bonus.','Workshop can fix economy: gain Silver or a key 4-cost like Smithy.']); }, say(evt, data){ if(evt==='shuffle'){ return this.postUnique(['Shuffle time! Minty fresh deck.','Cards doing cardio: shuffle complete.','Shuffledâ€”your Estates promised to behave.','Riffle, riffle. Deal me a win.','New order, who dis?',]); } if(evt==='playerBuy'){ const mapping = { Province:'Province! Bold move. I can smell the victory points.', Market:'Bought a Market. Economy go brrr.', Festival:'Festival acquired. Confetti not included.', Laboratory:'Lab online. Please wear safety goggles while drawing cards.', Woodcutter:'Woodcutter hired. Lumber? I hardly know her.', Merchant:'Merchant secured. May your Silvers be lucrative.', Workshop:'Workshop online. Time to craft value.', }; return this.post('bot', mapping[data?.name] || `Picked up ${data?.name}. Nice.`); } if(evt==='aiTurn'){ const bought = (data?.bought||[]).join(', ') || 'nothing'; const lines=[`AI bought ${bought}. We can beat that.`,`AI turn over. My analysis: ðŸ¤– mid.`, bought.includes('Province')? 'AI went green. Time to race!':'AI didn\'t touch Provinces. Opportunity knocks.', 'If AI buys nothing, we buy something shiny.','AI thinks long term. We think victory screen.',]; return this.postUnique(lines); } }
};

// ------------------- Sanity / smoke checks -------------------
function sanityCheck(){ try{ LOG_SILENT = true; const supplyPiles = document.querySelectorAll('#supply .pile').length; const okSupply = supplyPiles >= 14 && SUPPLY.some(p=>p.key==='Market') && SUPPLY.some(p=>p.key==='Merchant') && SUPPLY.some(p=>p.key==='Workshop'); const okHand = Array.isArray(game.player.hand) && game.player.hand.length === 5; const okFns = typeof CARD_DEFS?.Smithy?.effect === 'function' && typeof cardIcon === 'function'; const okChatRaised = getComputedStyle(document.getElementById('chatPanel')).bottom === '88px'; const dummy = { actions:0, buys:0, coins:0, player:{deck:[],discard:[],hand:[],played:[]}, ai:{}, aiActions:0, aiBuys:0, aiCoins:0, merchantPending:{player:0,ai:0} }; CARD_DEFS.Woodcutter.effect(dummy, dummy.player); const okPlusBuy = dummy.buys===1 && dummy.coins===2; CARD_DEFS.Laboratory.effect(dummy, dummy.player); const okLabAction = dummy.actions===1; CARD_DEFS.Merchant.effect(dummy, dummy.player); const okMerchantFlag = dummy.merchantPending.player===1; openGainChoice(4, dummy.player, 'Test'); const nameLayoutOK = document.querySelector('#choiceGrid .name .label')!==null; closeChoiceOverlay(); LOG_SILENT = false; if(!(okSupply && okHand && okFns && okPlusBuy && okLabAction && okMerchantFlag && okChatRaised && nameLayoutOK)){ const msg = `Sanity failed (supply:${okSupply}, hand5:${okHand}, fns:${okFns}, +Buy:${okPlusBuy}, lab+Action:${okLabAction}, merchantFlag:${okMerchantFlag}, chatRaised:${okChatRaised}, choiceLayout:${nameLayoutOK}).`; console.error(msg); toast(msg); } else { console.log('Sanity check passed.'); } }catch(e){ LOG_SILENT=false; console.error('Sanity check exception', e); toast('Sanity check exception'); } }

// ------------------- Start -------------------
init();
</script>
</body>
</html>
