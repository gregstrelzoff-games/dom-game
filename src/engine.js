function drawOne(actor){ if(actor.deck.length===0){ actor.deck.push(...actor.discard); actor.discard.length=0; shuffle(actor.deck); if(actor===game.player){ addLog('Your deck was shuffled.', 'mint'); Chat.say('shuffle'); } Sound.play('shuffle'); } if(actor.deck.length>0){ actor.hand.push(actor.deck.pop()); if(actor===game.player) Sound.play('draw'); }
function maybeAutoAdvance(){ if(game.interactionLock) return false; if(game.suppressAutoAdvanceOnce){ game.suppressAutoAdvanceOnce=false; return false; } if(!game.autoAdvance || game.gameOver) return false; let changed=false; if(game.phase==='action' && !hasPlayableAction()){ game.phase='treasure'; changed=true; } if(game.phase==='treasure' && !hasTreasure()){ game.phase='buy'; changed=true; } return changed; }
function phaseBand(){ const prov = getPile('Province'); const left = prov? prov.count : 12; if(left <= 3) return 'late'; if(left <= 7) return 'mid'; return 'early'; }
function snapshot(){ if(game.turn!=='player' || game.gameOver || game.interactionLock) return; game.undo = { turn: game.turn, phase: game.phase, actions: game.actions, buys: game.buys, coins: game.coins, endAfter: game.endAfterThisTurn, playerPacked: packActor(game.player), supply: SUPPLY.map(p=>p.count), logs: deepClone(logs), merchantPending: deepClone(game.merchantPending), turnNum: game.turnNum, }; game.undoForbidden = null; updateUndoUI(); }
function undo(){ if(!canUndo()) return; if(game.undoForbidden==='draw'){ Sound.play('error'); toast('You cannot use undo after a card draw.'); return; } if(isChoiceOpen()) closeChoiceOverlay(); const u = game.undo; game.turn  = u.turn; game.phase = u.phase; game.actions = u.actions; game.buys = u.buys; game.coins = u.coins; game.endAfterThisTurn = u.endAfter; game.player = unpackActor(u.playerPacked); SUPPLY.forEach((p,i)=> p.count = u.supply[i]); logs.length = 0; u.logs.forEach(x=> logs.push(x)); game.merchantPending = u.merchantPending; game.turnNum = u.turnNum; game.undo = null; game.interactionLock = false; game.suppressAutoAdvanceOnce = true; updateUndoUI(); addLog(`Undid last action. Restored phase: ${game.phase}, actions: ${game.actions}, buys: ${game.buys}, coins: ${game.coins}.`, 'mint'); render(); }
function play(index){ if(game.interactionLock || game.turn!=='player' || game.gameOver) return; const card = game.player.hand[index]; if(!card) return; snapshot(); if(card.type==='Action'){ if(game.phase!=='action' || game.actions<=0) return; game.actions -= 1; const [played] = game.player.hand.splice(index,1); game.player.played.push(played); if(typeof played.effect==='function') played.effect(game, game.player); Sound.play('action'); toast(`Played ${played.name}`); } else if(card.type==='Treasure'){ if(game.phase==='buy') { Sound.play('error'); return; } if(game.phase==='action') game.phase='treasure'; const [tre] = game.player.hand.splice(index,1); game.player.played.push(tre); let add = (tre.value||0); if(tre.name==='Silver' && game.merchantPending.player>0){ add += game.merchantPending.player; addLog(`Merchant boosts Silver: +${game.merchantPending.player}.`); game.merchantPending.player = 0; } game.coins += add; Sound.play('coins'); toast(`+${add} coins`); } render(); }
function autoPlayTreasures(){ if(game.turn!=='player' || game.phase==='buy' || game.gameOver) return; if(game.phase==='action') game.phase='treasure'; let added=0; let count=0; let sawSilver=false; for(let i=game.player.hand.length-1;i>=0;i--){ if(game.player.hand[i].type==='Treasure'){ const card = game.player.hand.splice(i,1)[0]; game.player.played.push(card); added += (card.value||0); count++; if(card.name==='Silver') sawSilver=true; } } if(sawSilver && game.merchantPending.player>0){ added += game.merchantPending.player; addLog(`Merchant boosts Silver: +${game.merchantPending.player}.`); game.merchantPending.player=0; } game.coins += added; if(count>0){ addLog(`Auto-played ${count} treasure${count>1?'s':''} for +${added} coins.`); Sound.play('coins'); toast(`Auto Treasures: +${added}`); } render(); }
function buy(name){ if(game.interactionLock || game.turn!=='player' || game.phase!=='buy' || game.gameOver) return; const pile = getPile(name); const def = CARD_DEFS[name]; if(!pile || !def || pile.count<=0) return; if(game.buys<=0){ Sound.play('error'); toast('No buys left'); return; } if(game.coins < def.cost){ Sound.play('error'); toast('Not enough coins'); return; } snapshot(); game.buys -= 1; game.coins -= def.cost; pile.count -= 1; game.player.discard.push(instance(def.name)); addLog(`You bought ${def.name} for ${def.cost}.`); Sound.play('buy'); toast(`Bought ${def.name} (-${def.cost})`); Chat.say?.('playerBuy', {name:def.name}); checkEndgameFlags(); render(); }
function endTurn(){ if(game.turn!=='player' || game.gameOver) return; game.undo = null; updateUndoUI(); cleanupAndDraw(game.player); lastCountsHTML = playerCountsHTML(); const pc = document.getElementById('playerCounts'); if(pc) pc.innerHTML = lastCountsHTML; if(endIfNeeded()) return; game.turn='ai'; game.actions=1; game.buys=1; game.coins=0; game.phase='action'; game.merchantPending.ai = 0; addLog('AI is thinking...'); render(); setTimeout(aiTurn, 300); }
function aiChooseBuyStrong(debug){ const coins = game.aiCoins; const phase = phaseBand(); const piles = { Province:getPile('Province'), Duchy:getPile('Duchy'), Estate:getPile('Estate'), Gold:getPile('Gold'), Silver:getPile('Silver'), Smithy:getPile('Smithy'), Village:getPile('Village'), Market:getPile('Market'), Laboratory:getPile('Laboratory'), Festival:getPile('Festival'), Woodcutter:getPile('Woodcutter'), Merchant:getPile('Merchant'), Workshop:getPile('Workshop') }; const can = n=> n && n.count>0; let pick=null; if(coins>=8 && can(piles.Province)) pick='Province'; else if(coins>=6 && can(piles.Gold)) pick='Gold'; else if(coins>=5){ const prefs = ['Festival','Market','Laboratory','Smithy']; pick = prefs.find(n=> can(piles[n])) || null; } else if(coins>=4 && can(piles.Smithy)) pick='Smithy'; else if(coins>=3){ const prefs3 = ['Silver','Village','Merchant','Workshop','Woodcutter']; pick = prefs3.find(n=> can(piles[n])) || null; } if(phase==='late' && !pick){ if(coins>=5 && can(piles.Duchy)) pick='Duchy'; else if(coins>=2 && can(piles.Estate)) pick='Estate'; } if(debug) debug.push(`Buy choice: ${pick??'nothing'} (coins ${coins})`); return pick; }
function aiMultiBuy(debug, mode){ let boughtList=[]; let safety=5; while(game.aiBuys>0 && safety-->0){ const choice = (mode==='weak') ? aiChooseBuyWeak(debug) : aiChooseBuyStrong(debug); if(!choice) break; const pile = getPile(choice); const def = CARD_DEFS[choice]; if(!pile || pile.count<=0 || game.aiCoins < def.cost) break; pile.count--; game.ai.discard.push(instance(choice)); game.aiCoins -= def.cost; game.aiBuys -= 1; boughtList.push(choice); checkEndgameFlags(); } return boughtList; }
function aiTurn(){ if(game.gameOver) return; const debug = game.debugAI ? [`AI turn start - hand: ${groupByName(game.ai.hand)}`] : null; game.aiActions=1; game.aiBuys=1; game.aiCoins=0; game.merchantPending.ai = 0; const mode = game.aiMode; if(mode==='weak'){ aiPlayBestActionWeak(debug); } else { let playedSomething=true; let guard=10; while(playedSomething && guard-->0){ playedSomething = aiPlayBestActionStrong(debug); } } const gained = aiAutoPlayTreasures(debug); const boughtList = aiMultiBuy(debug, mode); const bought = boughtList.length? boughtList.join(', '): 'nothing'; document.getElementById('ai-status').textContent = `AI (${mode}) played ${gained} coin${gained===1?'':'s'} and bought ${bought}.`; if(game.debugAI){ if(boughtList.length){ debug.push(`Bought: ${boughtList.join(', ')}`); } debug.push(`End coins: ${game.aiCoins}, End buys: ${game.aiBuys}`); writeAIDebug(debug); } else { writeAIDebug([]); } cleanupAndDraw(game.ai); if(endIfNeeded()) return; game.turn='player'; game.merchantPending.player = 0; game.turnNum += 1; addLog(`Your turn [${game.turnNum}].`); Chat.say?.('aiTurn', {bought:boughtList, coins:gained}); render(); }
function firstPlayableActionIndex(){ if(game.turn!=='player' || game.phase!=='action' || game.actions<=0 || game.interactionLock) return -1; return game.player.hand.findIndex(c=>c.type==='Action'); }